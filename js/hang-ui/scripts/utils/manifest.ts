/**
 * Utilities for loading and parsing Custom Elements Manifest (CEM)
 *
 * This module provides functions to:
 * - Load custom-elements.json generated by @custom-elements-manifest/analyzer
 * - Extract JSDoc metadata (@summary, @description, @example) from source files
 * - Enhance manifest with metadata from source comments
 * - Extract custom element definitions for code generation
 */

import { readFileSync } from "node:fs";
import { join } from "node:path";
import type { CustomElement, CustomElementsManifest, Declaration } from "./types";

type DeclarationWithExamples = Declaration & { examples?: Record<string, string>; customElement?: boolean };

/**
 * Extract JSDoc metadata from source file content
 *
 * Parses JSDoc blocks to find @tag, @summary, @description, and @example annotations.
 * Supports multiple labeled examples (e.g., @example HTML, @example React).
 *
 * @param content - Raw source file content to parse
 * @returns Map of tag names to their metadata (summary, description, examples)
 */
function extractJSDocMetadata(
	content: string,
): Map<string, { summary?: string; description?: string; examples?: Record<string, string> }> {
	const metadata = new Map<string, { summary?: string; description?: string; examples?: Record<string, string> }>();

	// Match JSDoc blocks with @tag, @summary, and @description
	const jsDocRegex = /\/\*\*([\s\S]*?)\*\//g;
	let match: RegExpExecArray | null = null;

	match = jsDocRegex.exec(content);
	while (match !== null) {
		const jsDocContent = match[1];

		// Extract @tag value
		const tagMatch = jsDocContent.match(/@tag\s+(\S+)/);
		if (!tagMatch) continue;

		const tag = tagMatch[1];

		// Extract @summary value (single line)
		const summaryMatch = jsDocContent.match(/@summary\s+([^\n]+)/);
		const summary = summaryMatch ? summaryMatch[1].trim() : undefined;

		// Extract @description value (can be multi-line until next @)
		const descriptionMatch = jsDocContent.match(/@description\s+([\s\S]*?)(?=@\w+|\*\/)/);
		const description = descriptionMatch ? descriptionMatch[1].trim() : undefined;

		// Extract all @example blocks with labels
		// Use matchAll() instead of exec() to avoid stateful regex issues
		const examples: Record<string, string> = {};

		// Match each @example with a label and its content
		// Content goes until we hit another @example or end of JSDoc block
		const exampleMatches = jsDocContent.matchAll(
			/@example\s+(\w+)\s*([\s\S]*?)(?=\n\s*\*\s*@example\s+\w|\*\/|$)/g,
		);

		for (const exampleMatch of exampleMatches) {
			const label = exampleMatch[1];
			let content = exampleMatch[2];

			// Remove JSDoc asterisks and clean up formatting
			content = content
				.split("\n")
				.map((line) => line.replace(/^\s*\*\s?/, ""))
				.join("\n")
				.trim();

			if (content) {
				examples[label] = content;
			}
		}

		metadata.set(tag, {
			summary,
			description,
			...(Object.keys(examples).length > 0 && { examples }),
		});

		match = jsDocRegex.exec(content);
	}

	return metadata;
}

/**
 * Load and enhance Custom Elements Manifest
 *
 * Loads custom-elements.json and enhances it with JSDoc metadata from source files.
 * This combines CEM analyzer output with hand-written documentation.
 *
 * @param basePath - Project root directory (defaults to cwd)
 * @returns Enhanced custom elements manifest
 * @throws Error if manifest file cannot be loaded
 */
export function loadManifest(basePath: string = process.cwd()): CustomElementsManifest {
	const manifestPath = join(basePath, "custom-elements.json");
	try {
		const content = readFileSync(manifestPath, "utf-8");
		const manifest = JSON.parse(content) as CustomElementsManifest;

		// Enhance manifest with JSDoc metadata from source files
		try {
			const watchSource = readFileSync(join(basePath, "src/watch/index.tsx"), "utf-8");
			const publishSource = readFileSync(join(basePath, "src/publish/index.tsx"), "utf-8");

			const watchMetadata = extractJSDocMetadata(watchSource);
			const publishMetadata = extractJSDocMetadata(publishSource);
			const allMetadata = new Map([...watchMetadata, ...publishMetadata]);

			// Update manifest declarations
			manifest.modules.forEach((mod) => {
				mod.declarations?.forEach((decl) => {
					if (decl.tagName && allMetadata.has(decl.tagName)) {
						const data = allMetadata.get(decl.tagName);
						if (!data) return;
						const declWithExamples = decl as DeclarationWithExamples;
						if (data.summary && !declWithExamples.summary) {
							declWithExamples.summary = data.summary;
						}
						if (data.description && !declWithExamples.description) {
							declWithExamples.description = data.description;
						}
						if (data.examples && !declWithExamples.examples) {
							declWithExamples.examples = data.examples;
						}
					}
				});
			});
		} catch (error) {
			const errorMsg = error instanceof Error ? error.message : String(error);
			console.warn(`⚠️  JSDoc enhancement failed: ${errorMsg}`);
		}

		return manifest;
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		console.error(`❌ Failed to load manifest: ${errorMsg}`);
		throw error;
	}
}

/**
 * Extract custom element definitions from manifest
 *
 * Filters manifest declarations to find only custom elements and extracts
 * their public API (attributes, properties, events, slots, etc.).
 * Deduplicates elements by tagName.
 *
 * @param manifest - Custom Elements Manifest to extract from
 * @returns Array of custom element definitions
 */
export function extractCustomElements(manifest: CustomElementsManifest): CustomElement[] {
	const elements: CustomElement[] = [];
	const seenTagNames = new Set<string>();

	manifest.modules.forEach((mod) => {
		mod.declarations?.forEach((decl: Declaration) => {
			const declWithExamples = decl as DeclarationWithExamples;
			// Look for custom elements either by kind or by customElement flag
			if ((decl.kind === "custom-element" || declWithExamples.customElement) && decl.tagName) {
				// Deduplate by tagName
				if (!seenTagNames.has(decl.tagName)) {
					seenTagNames.add(decl.tagName);
					elements.push({
						tagName: decl.tagName,
						className: decl.name,
						summary: decl.summary,
						description: decl.description,
						slots: decl.slots,
						events: decl.events,
						attributes: decl.attributes,
						properties: decl.properties,
						/**
						 * Convert kebab-case tag name to PascalCase component name
						 *
						 * Handles custom mappings for specific elements, otherwise converts
						 * kebab-case to PascalCase (e.g., "hang-watch-ui" → "HangWatchUI").
						 *
						 * @param tagName - Kebab-case custom element tag name
						 * @returns PascalCase component name
						 */
						examples: declWithExamples.examples,
					});
				}
			}
		});
	});

	return elements;
}

export function tagNameToComponentName(tagName: string): string {
	const customNames = {
		"hang-watch-ui": "HangWatchUI",
		"hang-publish-ui": "HangPublishUI",
	} as const satisfies Record<string, string>;

	if (tagName in customNames) {
		return customNames[tagName as keyof typeof customNames];
	}

	return tagName
		.split("-")
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1))
		.join("");
}
