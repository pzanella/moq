/**
 * Utilities for loading and parsing Custom Elements Manifest (CEM)
 *
 * This module provides functions to:
 * - Load custom-elements.json generated by @custom-elements-manifest/analyzer
 * - Extract JSDoc metadata (@summary, @description, @example) from source files
 * - Enhance manifest with metadata from source comments
 * - Extract custom element definitions for code generation
 */

import { existsSync, readdirSync, readFileSync, statSync } from "node:fs";
import { join } from "node:path";
import type { CustomElement, CustomElementsManifest, Declaration } from "./types";

type DeclarationWithExamples = Declaration & { examples?: Record<string, string>; customElement?: boolean };

/**
 * Extract JSDoc metadata from source file content
 *
 * Parses JSDoc blocks to find @tag, @summary, @description, and @example annotations.
 * Supports multiple labeled examples (e.g., @example HTML, @example React).
 *
 * @param content - Raw source file content to parse
 * @returns Map of tag names to their metadata (summary, description, examples)
 */
function extractJSDocMetadata(
	content: string,
): Map<string, { summary?: string; description?: string; examples?: Record<string, string> }> {
	const metadata = new Map<string, { summary?: string; description?: string; examples?: Record<string, string> }>();

	// Match JSDoc blocks with @tag, @summary, and @description
	const jsDocRegex = /\/\*\*([\s\S]*?)\*\//g;

	for (const match of content.matchAll(jsDocRegex)) {
		const jsDocContent = match[1];

		// Extract @tag value — skip blocks without @tag
		const tagMatch = jsDocContent.match(/@tag\s+(\S+)/);
		if (!tagMatch) continue;

		const tag = tagMatch[1];

		// Extract @summary value (single line)
		const summaryMatch = jsDocContent.match(/@summary\s+([^\n]+)/);
		const summary = summaryMatch ? summaryMatch[1].trim() : undefined;

		// Extract @description value (can be multi-line until next @)
		const descriptionMatch = jsDocContent.match(/@description\s+([\s\S]*?)(?=@\w+|\*\/)/);
		const description = descriptionMatch ? descriptionMatch[1].trim() : undefined;

		// Extract all @example blocks with labels
		// Use matchAll() instead of exec() to avoid stateful regex issues
		const examples: Record<string, string> = {};

		// Match each @example with a label and its content
		// Content goes until we hit another @example or end of JSDoc block
		const exampleMatches = jsDocContent.matchAll(
			/@example\s+(\w+)\s*([\s\S]*?)(?=\n\s*\*\s*@example\s+\w|\*\/|$)/g,
		);

		for (const exampleMatch of exampleMatches) {
			const label = exampleMatch[1];
			let content = exampleMatch[2];

			// Remove JSDoc asterisks and clean up formatting
			content = content
				.split("\n")
				.map((line) => line.replace(/^\s*\*\s?/, ""))
				.join("\n")
				.trim();

			if (content) {
				examples[label] = content;
			}
		}

		metadata.set(tag, {
			summary,
			description,
			...(Object.keys(examples).length > 0 && { examples }),
		});
	}

	return metadata;
}

/**
 * Load and enhance Custom Elements Manifest
 *
 * Loads custom-elements.json and enhances it with JSDoc metadata from source files.
 * This combines CEM analyzer output with hand-written documentation.
 *
 * @param basePath - Project root directory (defaults to cwd)
 * @returns Enhanced custom elements manifest
 * @throws Error if manifest file cannot be loaded
 */
export function loadManifest(basePath: string = process.cwd()): CustomElementsManifest {
	const manifestPath = join(basePath, "custom-elements.json");
	try {
		const content = readFileSync(manifestPath, "utf-8");
		const manifest = JSON.parse(content) as CustomElementsManifest;

		// Enhance manifest with JSDoc metadata from source files
		// Scan all .ts/.tsx files in src/ directory for JSDoc annotations
		try {
			const allMetadata = new Map<
				string,
				{ summary?: string; description?: string; examples?: Record<string, string> }
			>();

			// Recursively find and parse all TypeScript source files
			const srcDir = join(basePath, "src");

			if (existsSync(srcDir)) {
				const scanDirectory = (dir: string): void => {
					const entries = readdirSync(dir);
					for (const entry of entries) {
						const fullPath = join(dir, entry);
						const stat = statSync(fullPath);

						if (stat.isDirectory()) {
							scanDirectory(fullPath);
						} else if (entry.endsWith(".ts") || entry.endsWith(".tsx")) {
							const source = readFileSync(fullPath, "utf-8");
							const metadata = extractJSDocMetadata(source);
							for (const [tag, data] of metadata) {
								allMetadata.set(tag, data);
							}
						}
					}
				};

				scanDirectory(srcDir);
			}

			// Update manifest declarations
			manifest.modules.forEach((mod) => {
				mod.declarations?.forEach((decl) => {
					if (decl.tagName && allMetadata.has(decl.tagName)) {
						const data = allMetadata.get(decl.tagName);
						if (!data) return;
						const declWithExamples = decl as DeclarationWithExamples;
						if (data.summary && !declWithExamples.summary) {
							declWithExamples.summary = data.summary;
						}
						if (data.description && !declWithExamples.description) {
							declWithExamples.description = data.description;
						}
						if (data.examples && !declWithExamples.examples) {
							declWithExamples.examples = data.examples;
						}
					}
				});
			});
		} catch (error) {
			const errorMsg = error instanceof Error ? error.message : String(error);
			console.warn(`⚠️  JSDoc enhancement failed: ${errorMsg}`);
		}

		return manifest;
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		console.error(`❌ Failed to load manifest: ${errorMsg}`);
		throw error;
	}
}

/**
 * Extract custom element definitions from manifest
 *
 * Filters manifest declarations to find only custom elements and extracts
 * their public API (attributes, properties, events, slots, etc.).
 * Deduplicates elements by tagName.
 *
 * @param manifest - Custom Elements Manifest to extract from
 * @returns Array of custom element definitions
 */
export function extractCustomElements(manifest: CustomElementsManifest): CustomElement[] {
	const elements: CustomElement[] = [];
	const seenTagNames = new Set<string>();

	manifest.modules.forEach((mod) => {
		mod.declarations?.forEach((decl: Declaration) => {
			const declWithExamples = decl as DeclarationWithExamples;
			// Look for custom elements either by kind or by customElement flag
			if ((decl.kind === "custom-element" || declWithExamples.customElement) && decl.tagName) {
				// Deduplicate by tagName
				if (!seenTagNames.has(decl.tagName)) {
					seenTagNames.add(decl.tagName);
					elements.push({
						tagName: decl.tagName,
						className: decl.name,
						summary: decl.summary,
						description: decl.description,
						slots: decl.slots,
						events: decl.events,
						attributes: decl.attributes,
						properties: decl.properties,
						examples: declWithExamples.examples,
					});
				}
			}
		});
	});

	return elements;
}

/**
 * Convert kebab-case tag name to PascalCase component name
 *
 * Common abbreviations (e.g., "ui", "api") are kept uppercase.
 *
 * @example
 * tagNameToComponentName("my-element") // "MyElement"
 * tagNameToComponentName("video-player-ui") // "VideoPlayerUI"
 *
 * @param tagName - Kebab-case custom element tag name
 * @returns PascalCase component name
 */
export function tagNameToComponentName(tagName: string): string {
	return tagName
		.split("-")
		.map((part) => {
			// Keep "ui" uppercase if it's the last part
			if (part.toLowerCase() === "ui") {
				return "UI";
			}
			return part.charAt(0).toUpperCase() + part.slice(1);
		})
		.join("");
}
